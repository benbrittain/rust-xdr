// autogenerated by xdrust
// translated XDR->Rust types and functions
#[allow(dead_code)]
use std::{io, fmt};
use serde_xdr;
use xdrgen::xdr_rpc;
use tokio_core::io::EasyBuf;

xdr_enum!(GeoExperimentGroup {
  GeoInvalid = 0,
  GeoControl = 1,
  GeoExperiment = 2,
  GeoNumGroupTypes = 3,
});
xdr_enum!(ClusterType {
  CtExperimentClusterV0 = 0,
  CtExperimentClusterV1 = 1,
  CtNumClusterTypes = 2,
});
pub type Locid = i32;
pub type LocidVec = Vec<Locid>;

#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub struct LocationCluster {
  pub locid: Locid,
  pub last_updated: u32,
  pub cluster_id: u32,
  pub cluster_type: ClusterType,
}

#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub struct LocationClusterBatchArg {
  pub locs: LocidVec,
  pub cluster_arg: LocationCluster,
}

#[derive(Serialize, Deserialize, PartialEq, Debug)]
#[serde(rename(deserialize = "__UNION_SYMBOL__"))]
pub enum GetLocClusterRes {
  #[serde(rename = "0")]
  GeoInvalid {
  },
  // Default case for the XDR Union
  UnionDefault_ {
    loc_cluster: LocationCluster,
  },
}
pub type LocationClusterVec = Vec<LocationCluster>;

#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub enum ExampledbdProgRequest {
  V1(ExampledbdProgRequestV1),
}

#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub enum ExampledbdProgResponse {
  V1(ExampledbdProgResponseV1),
}

#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub enum ExampledbdProgRequestV1 {
  ExampledbdNull,
  GetLocationCluster(LocationCluster),
}

#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub enum ExampledbdProgResponseV1 {
  ExampledbdNull,
  GetLocationCluster(GetLocClusterRes),
}
pub fn exampledbd_prog_decode(program: u32, version: u32, procedure: u32, buf: &mut EasyBuf) ->
    io::Result<Option<ExampledbdProgRequest>> {
  match version  {
    1u32 => {
      exampledbd_prog_decode_v1(procedure, buf)
    },
    _ => {
      return Err(io::Error::new(io::ErrorKind::Other, "unknown version"));
    },
  }
}
pub fn exampledbd_prog_decode_v1(procedure: u32, buf: &mut EasyBuf) ->
    io::Result<Option<ExampledbdProgRequest>> {
  let request = match procedure {
    0u32 => {
      exampledbd_prog_decode_v1_exampledbd_null(buf)
    },
    1u32 => {
      exampledbd_prog_decode_v1_get_location_cluster(buf)
    },
    _ => {
      return Err(io::Error::new(io::ErrorKind::Other, "unknown procedure"));
    },
  };
  Ok(Some(ExampledbdProgRequest::V1(request.unwrap().unwrap())))
}
pub fn exampledbd_prog_decode_v1_exampledbd_null(buf: &mut EasyBuf) -> io::Result<Option<ExampledbdProgRequestV1>> {
  Ok(Some(ExampledbdProgRequestV1::ExampledbdNull))
}
pub fn exampledbd_prog_decode_v1_get_location_cluster(buf: &mut EasyBuf) -> io::Result<Option<ExampledbdProgRequestV1>> {
  let res0 = serde_xdr::from_bytes::<LocationCluster>(buf.as_slice());
    let arg0 = match res0 {
        Ok((arg, consumed)) => {
            buf.drain_to(consumed);
            arg
        },
        Err(e) => {
            match e {
                serde_xdr::EncoderError::Io(i) => {
                    return Err(i);
                },
                serde_xdr::EncoderError::Unknown(s) => {
                    return Err(io::Error::new(io::ErrorKind::Other,
                        format!("argument 0 parse failure: {}", s)));
                }
            }
        }
    };

  Ok(Some(ExampledbdProgRequestV1::GetLocationCluster(arg0)))
}
pub fn encode(msg: ExampledbdProgResponse, buf: &mut Vec<u8>) -> io::Result<()> {
  match msg  {
    ExampledbdProgResponse::V1(rsp) => {
      match rsp  {
        ExampledbdProgResponseV1::ExampledbdNull => {
        },
        ExampledbdProgResponseV1::GetLocationCluster(r) => {
          try!(serde_xdr::to_bytes(&r, buf));
        },
        _ => {
          return Err(io::Error::new(io::ErrorKind::Other, "unknown procedure"));
        },
      }
      Ok(())
    },
    _ => {
      return Err(io::Error::new(io::ErrorKind::Other, "unknown version"));
    },
  }
}
