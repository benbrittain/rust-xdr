// Autogenerated by xdrust
#[allow(dead_code)]
use std::io;
use std::ops::DerefMut;
use tokio_service::Service;
use futures::{future, Future, BoxFuture};
use tokio_core::io::EasyBuf;
use futures_cpupool::CpuPool;
use xdrgen::xdr_rpc;
use xdrgen::prot::*;
use std::default::Default;
use serde_xdr;

use service::*;
impl Service for ExampledbdProgService {
  type Request = xdr_rpc::XdrRequest<ExampledbdProgRequest>;
  type Response = xdr_rpc::XdrResponse<ExampledbdProgResponse>;
  type Error = io::Error;
  type Future = BoxFuture<Self::Response, Self::Error>;
  fn call (&self, req: Self::Request) -> Self::Future {
    let xid = req.xid;
    match req.val  {
      ExampledbdProgRequest::V1(data) => {
        let res = match data {
          ExampledbdProgRequestV1::ExampledbdNull => {
            self.exampledbd_null_v1().map(|r| {
                ExampledbdProgResponseV1::ExampledbdNull
              }).boxed()
          },
          ExampledbdProgRequestV1::GetLocationCluster(arg0) => {
            self.get_location_cluster_v1(arg0).map(|r| {
                ExampledbdProgResponseV1::GetLocationCluster(r)
              }).boxed()
          },
          _ => {
            return future::err(io::Error::new(io::ErrorKind::Other, "unknown procedure")).boxed();
          },
        };
        res.map(move |r| {
            xdr_rpc::XdrResponse{ xid: xid, val: ExampledbdProgResponse::V1(r) }
          }).boxed()
      },
      _ => {
        return future::err(io::Error::new(io::ErrorKind::Other, "unknown version")).boxed();
      },
    }
  }
}
